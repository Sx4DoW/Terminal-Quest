<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dungeon Room</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #000;
        }
        canvas {
            border: 1px solid #0f0;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
        }
        .controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border: 1px solid #0f0;
            color: #0f0;
            font-family: monospace;
        }
        button {
            background: #001a00;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 8px 15px;
            cursor: pointer;
            font-family: monospace;
            margin: 5px;
        }
        button:hover {
            background: #003300;
        }
    </style>
</head>
<body>
    <canvas id="room" width="720" height="720"></canvas>
    <div class="controls">
        <div>Dungeon Room (Top-Down)</div>
        <button onclick="downloadImage()">Download PNG</button>
    </div>

    <script>
        const canvas = document.getElementById('room');
        const ctx = canvas.getContext('2d');
        const size = 720;
        const tileSize = 24;
        const wallThickness = 80;

        // Colors - dark stone dungeon palette
        const colors = {
            wall: '#2a2a2a',
            wallHighlight: '#3f3f3f',
            wallShadow: '#181818',
            floor: '#3d3d3d',
            floorAlt: '#323232',
            tileEdge: '#202020',
            accent: '#4d4d4d'
        };

        // Fill background
        ctx.fillStyle = '#000f00';
        ctx.fillRect(0, 0, size, size);

        // Draw floor tiles
        const floorStartX = wallThickness;
        const floorStartY = wallThickness;
        const floorWidth = size - (wallThickness * 2);
        const floorHeight = size - (wallThickness * 2);

        for (let y = floorStartY; y < floorStartY + floorHeight; y += tileSize) {
            for (let x = floorStartX; x < floorStartX + floorWidth; x += tileSize) {
                const tileX = Math.floor((x - floorStartX) / tileSize);
                const tileY = Math.floor((y - floorStartY) / tileSize);
                
                // Checkerboard pattern
                const isAlt = (tileX + tileY) % 2 === 0;
                ctx.fillStyle = isAlt ? colors.floor : colors.floorAlt;
                ctx.fillRect(x, y, tileSize, tileSize);

                // Tile edges for definition
                ctx.strokeStyle = colors.tileEdge;
                ctx.lineWidth = 1;
                ctx.strokeRect(x, y, tileSize, tileSize);

                // Add subtle noise
                const noise = (Math.random() - 0.5) * 0.1;
                ctx.fillStyle = `rgba(0, 255, 0, ${noise})`;
                ctx.fillRect(x, y, tileSize, tileSize);
            }
        }

        // Draw walls with depth
        function drawWall(x, y, w, h) {
            // Base wall
            ctx.fillStyle = colors.wall;
            ctx.fillRect(x, y, w, h);

            // Inner shadow
            const gradient = ctx.createLinearGradient(x, y, x + Math.min(w, h) * 0.3, y + Math.min(w, h) * 0.3);
            gradient.addColorStop(0, colors.wallShadow);
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(x, y, w, h);

            // Outer highlight
            ctx.strokeStyle = colors.wallHighlight;
            ctx.lineWidth = 2;
            ctx.strokeRect(x + 1, y + 1, w - 2, h - 2);

            // Add texture
            ctx.strokeStyle = colors.tileEdge;
            ctx.lineWidth = 1;
            for (let i = 0; i < (w > h ? w : h); i += 20) {
                if (w > h) {
                    ctx.beginPath();
                    ctx.moveTo(x + i, y);
                    ctx.lineTo(x + i, y + h);
                    ctx.stroke();
                } else {
                    ctx.beginPath();
                    ctx.moveTo(x, y + i);
                    ctx.lineTo(x + w, y + i);
                    ctx.stroke();
                }
            }
        }

        // Top wall
        drawWall(0, 0, size, wallThickness);
        // Bottom wall
        drawWall(0, size - wallThickness, size, wallThickness);
        // Left wall
        drawWall(0, 0, wallThickness, size);
        // Right wall
        drawWall(size - wallThickness, 0, wallThickness, size);

        // Add corner accents
        ctx.fillStyle = colors.accent;
        const cornerSize = 20;
        // Top-left
        ctx.fillRect(wallThickness - cornerSize, wallThickness - cornerSize, cornerSize, cornerSize);
        // Top-right
        ctx.fillRect(size - wallThickness, wallThickness - cornerSize, cornerSize, cornerSize);
        // Bottom-left
        ctx.fillRect(wallThickness - cornerSize, size - wallThickness, cornerSize, cornerSize);
        // Bottom-right
        ctx.fillRect(size - wallThickness, size - wallThickness, cornerSize, cornerSize);

        // Add scanlines for CRT effect
        ctx.strokeStyle = 'rgba(0, 20, 0, 0.1)';
        ctx.lineWidth = 1;
        for (let y = 0; y < size; y += 3) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(size, y);
            ctx.stroke();
        }

        // Add subtle overall noise
        const imageData = ctx.getImageData(0, 0, size, size);
        const data = imageData.data;
        for (let i = 0; i < data.length; i += 4) {
            const noise = (Math.random() - 0.5) * 6;
            data[i] += noise;
            data[i + 1] += noise;
            data[i + 2] += noise;
        }
        ctx.putImageData(imageData, 0, 0);

        function downloadImage() {
            const link = document.createElement('a');
            link.download = 'dungeon_room_720x720.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
        }
    </script>
</body>
</html>